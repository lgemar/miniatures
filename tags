!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ADD	ExpressionTree.hpp	10;"	d
CS207	CS207/Color.hpp	/^namespace CS207 {$/;"	n
CS207	CS207/GLCamera.hpp	/^namespace CS207 {$/;"	n
CS207	CS207/SDLViewer.hpp	/^namespace CS207 {$/;"	n
CS207	CS207/Util.hpp	/^namespace CS207 {$/;"	n
CS207_COLOR_HPP	CS207/Color.hpp	2;"	d
CS207_GLCAMERA_HPP	CS207/GLCamera.hpp	2;"	d
CS207_POINT_HPP	Point.hpp	2;"	d
CS207_SDLVIEWER_HPP	CS207/SDLViewer.hpp	2;"	d
CS207_UTIL_HPP	CS207/Util.hpp	2;"	d
CXX	Makefile	/^CXX := $(shell which clang++) -std=c++11 -g$/;"	m
Clock	CS207/Util.hpp	/^  Clock() : starttime_(clock::now()) {}$/;"	f	class:CS207::Clock
Clock	CS207/Util.hpp	/^class Clock {$/;"	c	namespace:CS207
Color	CS207/Color.hpp	/^  Color() $/;"	f	struct:CS207::Color
Color	CS207/Color.hpp	/^  Color(float r, float g, float b)$/;"	f	struct:CS207::Color
Color	CS207/Color.hpp	/^  Color(float v)$/;"	f	struct:CS207::Color
Color	CS207/Color.hpp	/^struct Color {$/;"	s	namespace:CS207
Constraint	mass_spring.cpp	/^	Constraint(Rule* s) {$/;"	f	struct:Constraint
Constraint	mass_spring.cpp	/^	Constraint(f_composition composite) : constraints_(composite) {$/;"	f	struct:Constraint
Constraint	mass_spring.cpp	/^struct Constraint {$/;"	s	file:
Cycle	Permutation.hpp	/^		Cycle( string a ) {$/;"	f	class:Cycle
Cycle	Permutation.hpp	/^class Cycle {$/;"	c
DEBUG	evaluate.cpp	11;"	d	file:
DEPSDIR	Makefile	/^DEPSDIR := $(shell mkdir -p .deps; echo .deps)$/;"	m
DEPSFILE	Makefile	/^DEPSFILE = $(DEPSDIR)\/$(notdir $*.d)$/;"	m
DEPSFLAGS	Makefile	/^DEPSFLAGS = -MD -MF $(DEPSFILE) -MP$/;"	m
DIV	ExpressionTree.hpp	13;"	d
DampingForce	mass_spring.cpp	/^	DampingForce(scalar coeff) : coeff_(coeff) {$/;"	f	struct:DampingForce
DampingForce	mass_spring.cpp	/^struct DampingForce : public Stimulus {$/;"	s	file:
DefaultColor	CS207/SDLViewer.hpp	/^struct DefaultColor {$/;"	s	namespace:CS207
DefaultPosition	CS207/SDLViewer.hpp	/^struct DefaultPosition {$/;"	s	namespace:CS207
Edge	Graph.hpp	/^			Edge() : g_(NULL), eid_(-1) {$/;"	f	class:Graph::Edge
Edge	Graph.hpp	/^			Edge(const Graph* g, eid_type eid) : g_(g), eid_(eid) {}$/;"	f	class:Graph::Edge
Edge	Graph.hpp	/^	class Edge : private totally_ordered<Edge> {$/;"	c	class:Graph
Edge	mass_spring.cpp	/^typedef typename GraphType::edge_type Edge;$/;"	t	file:
Edge	shortest_path.cpp	/^typedef GraphType::edge_type Edge;$/;"	t	file:
EdgeInfo	Graph.hpp	/^		EdgeInfo(idx_type i, nid_type n1, nid_type n2, EdgeData v) :$/;"	f	struct:Graph::EdgeInfo
EdgeInfo	Graph.hpp	/^	struct EdgeInfo {$/;"	s	class:Graph
ExpressionTree	ExpressionTree.hpp	/^	ExpressionTree(const char* s) {$/;"	f	class:ExpressionTree
ExpressionTree	ExpressionTree.hpp	/^	ExpressionTree(const std::string s) {$/;"	f	class:ExpressionTree
ExpressionTree	ExpressionTree.hpp	/^class ExpressionTree {$/;"	c
FieldElement	Field.hpp	/^		FieldElement(FiniteField* f, value_type val) : val(val), f_(f) {$/;"	f	class:FiniteField::FieldElement
FieldElement	Field.hpp	/^	class FieldElement {$/;"	c	class:FiniteField
FiniteField	Field.hpp	/^	FiniteField(IT begin, IT end, ADD add, MULT multiply, bool debug=false):$/;"	f	class:FiniteField
FiniteField	Field.hpp	/^class FiniteField {$/;"	c
FireBall	mass_spring.cpp	/^struct FireBall : public Rule {$/;"	s	file:
Force	mass_spring.cpp	/^	Force(Stimulus* s) {$/;"	f	struct:Force
Force	mass_spring.cpp	/^	Force(f_composition composite) : forces_(composite) {$/;"	f	struct:Force
Force	mass_spring.cpp	/^struct Force {$/;"	s	file:
GLCamera	CS207/GLCamera.hpp	/^  GLCamera()$/;"	f	class:CS207::GLCamera
GLCamera	CS207/GLCamera.hpp	/^class GLCamera {$/;"	c	namespace:CS207
Graph	Graph.hpp	/^	Graph(bool directed = false) : directed_(directed) {$/;"	f	class:Graph
Graph	Graph.hpp	/^class Graph {$/;"	c
GraphType	mass_spring.cpp	/^typedef Graph<node_data, edge_data> GraphType;$/;"	t	file:
GraphType	shortest_path.cpp	/^typedef Graph<MyNodeData, double> GraphType;$/;"	t	file:
GraphType	test_nodes.cpp	/^typedef Graph<int, int> GraphType;$/;"	t	file:
GravityForce	mass_spring.cpp	/^struct GravityForce : public Stimulus {$/;"	s	file:
MAP	Permutation.hpp	/^typedef map<char, char> MAP;$/;"	t
MULT	ExpressionTree.hpp	12;"	d
MassSpringForce	mass_spring.cpp	/^struct MassSpringForce : public Stimulus {$/;"	s	file:
MyColorFunc	shortest_path.cpp	/^	MyColorFunc(double longest_path) : lp_(longest_path) {$/;"	f	struct:MyColorFunc
MyColorFunc	shortest_path.cpp	/^struct MyColorFunc {$/;"	s	file:
MyComparator	shortest_path.cpp	/^   MyComparator(const Point& p) : p_(p) {$/;"	f	struct:MyComparator
MyComparator	shortest_path.cpp	/^struct MyComparator {$/;"	s	file:
MyNodeData	shortest_path.cpp	/^struct MyNodeData {$/;"	s	file:
N	evaluate.cpp	/^	int N;$/;"	m	struct:mod_adder	file:
N	evaluate.cpp	/^	int N;$/;"	m	struct:mod_multiplier	file:
N	fields.cpp	/^	int N;$/;"	m	struct:add_modN	file:
N	fields.cpp	/^	int N;$/;"	m	struct:mult_modN	file:
Node	Graph.hpp	/^			Node() : g_(NULL), nid_(-1) {$/;"	f	class:Graph::Node
Node	Graph.hpp	/^			Node(const Graph* g, nid_type nid) : g_(g), nid_(nid) {}$/;"	f	class:Graph::Node
Node	Graph.hpp	/^	class Node : private totally_ordered<Node> {$/;"	c	class:Graph
Node	mass_spring.cpp	/^typedef typename GraphType::node_type Node;$/;"	t	file:
Node	shortest_path.cpp	/^typedef GraphType::node_type Node;$/;"	t	file:
Node	test_nodes.cpp	/^typedef GraphType::node_type Node;$/;"	t	file:
NodeInfo	Graph.hpp	/^		NodeInfo(idx_type idx, Point pos, NodeData data) :$/;"	f	struct:Graph::NodeInfo
NodeInfo	Graph.hpp	/^	struct NodeInfo {$/;"	s	class:Graph
Operator	Field.hpp	/^		Operator(FiniteField* f, char type) : type(type), f_(f) {$/;"	f	class:FiniteField::Operator
Operator	Field.hpp	/^	class Operator {$/;"	c	class:FiniteField
PAIR	Permutation.hpp	/^typedef pair<char, char> PAIR;$/;"	t
Permutation	Permutation.hpp	/^		Permutation( string a ) {$/;"	f	class:Permutation
Permutation	Permutation.hpp	/^		Permutation() {$/;"	f	class:Permutation
Permutation	Permutation.hpp	/^class Permutation {$/;"	c
Point	Point.hpp	/^  Point() {$/;"	f	struct:Point
Point	Point.hpp	/^  Point(value_type b0, value_type b1, value_type b2) {$/;"	f	struct:Point
Point	Point.hpp	/^  explicit Point(value_type b) {$/;"	f	struct:Point
Point	Point.hpp	/^struct Point {$/;"	s
PoissonColor	CS207/SDLViewer.hpp	/^struct PoissonColor {$/;"	s	namespace:CS207
PoissonPosition	CS207/SDLViewer.hpp	/^struct PoissonPosition {$/;"	s	namespace:CS207
Polynomial	polys.hpp	/^	Polynomial() : coeffs_(coeff_array()) {}$/;"	f	class:Polynomial
Polynomial	polys.hpp	/^	Polynomial(coeff_array c) : coeffs_(c) {}$/;"	f	class:Polynomial
Polynomial	polys.hpp	/^	Polynomial(int a, int b) {$/;"	f	class:Polynomial
Polynomial	polys.hpp	/^	Polynomial(int a, int b, int c) {$/;"	f	class:Polynomial
Polynomial	polys.hpp	/^	Polynomial(std::string s) : coeffs_(coeff_array()) {$/;"	f	class:Polynomial
Polynomial	polys.hpp	/^class Polynomial {$/;"	c
Rule	mass_spring.cpp	/^struct Rule {$/;"	s	file:
SDLViewer	CS207/SDLViewer.hpp	/^  SDLViewer()$/;"	f	class:CS207::SDLViewer
SDLViewer	CS207/SDLViewer.hpp	/^class SDLViewer {$/;"	c	namespace:CS207
SET	pmul.cpp	/^typedef set<char> SET;$/;"	t	file:
SUB	ExpressionTree.hpp	11;"	d
Sphere	mass_spring.cpp	/^struct Sphere : public Rule {$/;"	s	file:
Stimulus	mass_spring.cpp	/^struct Stimulus {$/;"	s	file:
TableTop	mass_spring.cpp	/^struct TableTop : public Rule {$/;"	s	file:
TransformIter	Graph.hpp	/^			TransformIter() : g_(NULL), it_(IT()) {$/;"	f	class:Graph::TransformIter
TransformIter	Graph.hpp	/^			TransformIter(const Graph* g, IT it) : it_(it), g_(g) {}$/;"	f	class:Graph::TransformIter
TransformIter	Graph.hpp	/^	class TransformIter : private equality_comparable<TransformIter<IT, T>>{$/;"	c	class:Graph
UNAME	Makefile	/^UNAME := $(shell uname)$/;"	m
VALUE	ExpressionTree.hpp	9;"	d
add_	Field.hpp	/^	adder add_;$/;"	m	class:FiniteField
add_edge	Graph.hpp	/^	edge_type add_edge(const node_type& n1, $/;"	f	class:Graph
add_edges	CS207/SDLViewer.hpp	/^  void add_edges(InputIterator first, InputIterator last, const Map& node_map) {$/;"	f	class:CS207::SDLViewer
add_modN	fields.cpp	/^	add_modN(int N) : N(N) {}$/;"	f	struct:add_modN
add_modN	fields.cpp	/^struct add_modN {$/;"	s	file:
add_node	Graph.hpp	/^	node_type add_node(Point p, $/;"	f	class:Graph
add_nodes	CS207/SDLViewer.hpp	/^  void add_nodes(InputIterator first, InputIterator last,$/;"	f	class:CS207::SDLViewer
add_reducer	evaluate.cpp	/^	void add_reducer(coeff_power_swap r) {$/;"	f	struct:poly_multiplier
adder	Field.hpp	/^	typedef ADD adder;$/;"	t	class:FiniteField
addinv_map_	Field.hpp	/^	map addinv_map_;$/;"	m	class:FiniteField
addition_table_	Field.hpp	/^	table addition_table_;$/;"	m	class:FiniteField
all_zeros	polys.hpp	/^	bool all_zeros(coeff_array c) {$/;"	f	class:Polynomial
apply	mass_spring.cpp	/^	virtual Point apply(Node n, double t) {$/;"	f	struct:DampingForce
apply	mass_spring.cpp	/^	virtual Point apply(Node n, double t) {$/;"	f	struct:GravityForce
apply	mass_spring.cpp	/^	virtual void apply(GraphType& g, double t) {$/;"	f	struct:FireBall
apply	mass_spring.cpp	/^	virtual void apply(GraphType& g, double t) {$/;"	f	struct:Sphere
apply	mass_spring.cpp	/^	virtual void apply(GraphType& g, double t) {$/;"	f	struct:TableTop
apply	mass_spring.cpp	/^  virtual Point apply(Node n, double t) {$/;"	f	struct:MassSpringForce
b	CS207/Color.hpp	/^  value_type r, g, b;$/;"	m	struct:CS207::Color
back	Point.hpp	/^  const_reference back()  const { return elem[2]; }$/;"	f	struct:Point
back	Point.hpp	/^  reference       back()        { return elem[2]; }$/;"	f	struct:Point
begin	ExpressionTree.hpp	/^	term_list::iterator begin() {$/;"	f	class:ExpressionTree
begin	Point.hpp	/^  const_iterator  begin() const { return elem; }$/;"	f	struct:Point
begin	Point.hpp	/^  iterator        begin()       { return elem; }$/;"	f	struct:Point
build	pmul.cpp	/^string build( Permutation& p, const SET e ) {$/;"	f
build_element	Field.hpp	/^	element build_element(VAL a) {$/;"	f	class:FiniteField
build_tree_	ExpressionTree.hpp	/^	term build_tree_(std::string s) {$/;"	f	class:ExpressionTree
camera_	CS207/SDLViewer.hpp	/^  GLCamera camera_;$/;"	m	class:CS207::SDLViewer
cbegin	Point.hpp	/^  const_iterator cbegin() const { return elem; }$/;"	f	struct:Point
cend	Point.hpp	/^  const_iterator   cend() const { return elem+3; }$/;"	f	struct:Point
center_view	CS207/SDLViewer.hpp	/^  void center_view() {$/;"	f	class:CS207::SDLViewer
check_additive_inverses	Field.hpp	/^	void check_additive_inverses() {$/;"	f	class:FiniteField
check_associativity	Field.hpp	/^	void check_associativity() {$/;"	f	class:FiniteField
check_closure	Field.hpp	/^	void check_closure() {$/;"	f	class:FiniteField
check_commutativity	Field.hpp	/^	void check_commutativity() {$/;"	f	class:FiniteField
check_distributivity	Field.hpp	/^	void check_distributivity() {$/;"	f	class:FiniteField
check_division	Field.hpp	/^	void check_division() {$/;"	f	class:FiniteField
check_gl_error	CS207/SDLViewer.hpp	/^  void check_gl_error(const char* context = nullptr) {$/;"	f	class:CS207::SDLViewer
check_if_trivial	Field.hpp	/^	void check_if_trivial() {$/;"	f	class:FiniteField
check_multiplicative_inverses	Field.hpp	/^	void check_multiplicative_inverses() {$/;"	f	class:FiniteField
check_one_element	Field.hpp	/^	void check_one_element() {$/;"	f	class:FiniteField
check_subtraction	Field.hpp	/^	void check_subtraction() {$/;"	f	class:FiniteField
check_zero_element	Field.hpp	/^	void check_zero_element() {$/;"	f	class:FiniteField
clear	CS207/SDLViewer.hpp	/^  void clear() {$/;"	f	class:CS207::SDLViewer
clear	Graph.hpp	/^		void clear() {$/;"	f	struct:Graph::EdgeInfo
clear	Graph.hpp	/^		void clear() {$/;"	f	struct:Graph::NodeInfo
clear	Graph.hpp	/^	void clear() {$/;"	f	class:Graph
clear_data_	Graph.hpp	/^	void clear_data_() {$/;"	f	class:Graph
clock	CS207/Util.hpp	/^  typedef std::chrono::high_resolution_clock clock;$/;"	t	class:CS207::Clock
clone	Permutation.hpp	/^		Permutation* clone() {$/;"	f	class:Permutation
coeff_	mass_spring.cpp	/^	scalar coeff_;$/;"	m	struct:DampingForce	file:
coeff_add	polys.hpp	/^coeff_array coeff_add(coeff_array a, coeff_array b) {$/;"	f
coeff_array	polys.hpp	/^typedef std::vector<int> coeff_array;$/;"	t
coeff_modulo	evaluate.cpp	/^	coeff_modulo() : mod(1) {}$/;"	f	struct:coeff_modulo
coeff_modulo	evaluate.cpp	/^	coeff_modulo(int mod) : mod(mod) {}$/;"	f	struct:coeff_modulo
coeff_modulo	evaluate.cpp	/^typedef struct coeff_modulo {$/;"	s	file:
coeff_modulo	evaluate.cpp	/^} coeff_modulo;$/;"	t	typeref:struct:coeff_modulo	file:
coeff_multiply	polys.hpp	/^coeff_array coeff_multiply(coeff_array a, coeff_array b) {$/;"	f
coeff_power_swap	evaluate.cpp	/^	coeff_power_swap() : pow(0), sub(coeff_array()) {}$/;"	f	struct:coeff_power_swap
coeff_power_swap	evaluate.cpp	/^	coeff_power_swap(int power, coeff_array replacement) : $/;"	f	struct:coeff_power_swap
coeff_power_swap	evaluate.cpp	/^typedef struct coeff_power_swap {$/;"	s	file:
coeff_power_swap	evaluate.cpp	/^} coeff_power_swap;$/;"	t	typeref:struct:coeff_power_swap	file:
coeff_scalar_multiply	polys.hpp	/^coeff_array coeff_scalar_multiply(coeff_array a, int s) {$/;"	f
coeff_shift_right	polys.hpp	/^coeff_array coeff_shift_right(coeff_array a, int shift_amount) {$/;"	f
coeffs_	polys.hpp	/^	coeff_array coeffs_;$/;"	m	class:Polynomial
coeffs_from_term	polys.hpp	/^	coeff_array coeffs_from_term(std::string s) {$/;"	f	class:Polynomial
colors_	CS207/SDLViewer.hpp	/^  std::vector<Color> colors_;$/;"	m	class:CS207::SDLViewer
const_iterator	Point.hpp	/^  typedef const double*   const_iterator;$/;"	t	struct:Point
const_reference	Point.hpp	/^  typedef const double&   const_reference;$/;"	t	struct:Point
constraints_	mass_spring.cpp	/^	f_composition constraints_;$/;"	m	struct:Constraint	file:
contains	polys.hpp	/^	size_t contains(std::string s, char c) {$/;"	f	class:Polynomial
coords_	CS207/SDLViewer.hpp	/^  std::vector<Point> coords_;$/;"	m	class:CS207::SDLViewer
cross	Point.hpp	/^Point cross(const Point& a, const Point& b) {$/;"	f
cycles_	Permutation.hpp	/^		list<Cycle> cycles_;$/;"	m	class:Permutation
data	Graph.hpp	/^		mutable EdgeData data;$/;"	m	struct:Graph::EdgeInfo
data	Graph.hpp	/^		mutable NodeData data;$/;"	m	struct:Graph::NodeInfo
data	Point.hpp	/^  const_iterator  data() const { return elem; }$/;"	f	struct:Point
data	Point.hpp	/^  iterator        data()       { return elem; }$/;"	f	struct:Point
db	Field.hpp	/^	void db(S s) {$/;"	f	class:FiniteField
db	Field.hpp	/^	void db(S t, U u) {$/;"	f	class:FiniteField
db	db.hpp	/^void db(T s) {$/;"	f
db	db.hpp	/^void db(T s1, U s2) {$/;"	f
db	db.hpp	/^void db(T s1, U s2, V s3) {$/;"	f
db	debug.hpp	/^void db(T s) {$/;"	f
db	debug.hpp	/^void db(T s1, U s2) {$/;"	f
dbg	Field.hpp	/^	void dbg(const S1 s1) {$/;"	f	class:FiniteField
dbg	db.hpp	/^void dbg(const S1 s1) {$/;"	f
dbr	Field.hpp	/^	void dbr(const S1 s1) {$/;"	f	class:FiniteField
debug_	Field.hpp	/^	bool debug_;$/;"	m	class:FiniteField
default_generator	CS207/Util.hpp	/^static std::mt19937 default_generator;$/;"	m	namespace:CS207
degree	Graph.hpp	/^			size_t degree() const {$/;"	f	class:Graph::Node
difference_type	Graph.hpp	/^			typedef std::ptrdiff_t difference_type;$/;"	t	class:Graph::TransformIter
difference_type	Point.hpp	/^  typedef std::ptrdiff_t  difference_type;$/;"	t	struct:Point
directed_	Graph.hpp	/^	const bool directed_;$/;"	m	class:Graph
dist	CS207/GLCamera.hpp	/^  float dist;$/;"	m	class:CS207::GLCamera
dist	shortest_path.cpp	/^	double dist;$/;"	m	struct:MyNodeData	file:
distance	Point.hpp	/^float distance(const Point& a, const Point& b) {$/;"	f
dot	Point.hpp	/^double dot(const Point& a, const Point& b) {$/;"	f
draw_graph	CS207/SDLViewer.hpp	/^  void draw_graph(const G& g) {$/;"	f	class:CS207::SDLViewer
draw_graph_nodes	CS207/SDLViewer.hpp	/^  void draw_graph_nodes(const G& g) {$/;"	f	class:CS207::SDLViewer
duration	CS207/Util.hpp	/^  typedef typename clock::duration           duration;$/;"	t	class:CS207::Clock
e_tree	evaluate.cpp	/^typedef ExpressionTree e_tree;$/;"	t	file:
e_tree	parse.cpp	/^typedef ExpressionTree e_tree;$/;"	t	file:
e_tree	polys.hpp	/^typedef ExpressionTree e_tree;$/;"	t
edge_begin	Graph.hpp	/^			incident_iterator edge_begin() {$/;"	f	class:Graph::Node
edge_begin	Graph.hpp	/^	edge_iterator edge_begin() {$/;"	f	class:Graph
edge_data	mass_spring.cpp	/^	edge_data() : rest_length(0) {}$/;"	f	struct:edge_data
edge_data	mass_spring.cpp	/^	edge_data(double l) : rest_length(l) {}$/;"	f	struct:edge_data
edge_data	mass_spring.cpp	/^struct edge_data {$/;"	s	file:
edge_end	Graph.hpp	/^			incident_iterator edge_end() {$/;"	f	class:Graph::Node
edge_end	Graph.hpp	/^	edge_iterator edge_end() {$/;"	f	class:Graph
edge_iterator	Graph.hpp	/^	typedef TransformIter<eid_list::iterator, edge_type> edge_iterator;$/;"	t	class:Graph
edge_type	Graph.hpp	/^	typedef Edge edge_type;$/;"	t	class:Graph
edge_value_type	Graph.hpp	/^	typedef EdgeData edge_value_type;$/;"	t	class:Graph
edges_	CS207/SDLViewer.hpp	/^  std::vector<unsigned> edges_;$/;"	m	class:CS207::SDLViewer
edges_	Graph.hpp	/^	std::vector<EdgeInfo> edges_;$/;"	m	class:Graph
eid_	Graph.hpp	/^			int eid_;$/;"	m	class:Graph::Edge
eid_list	Graph.hpp	/^	typedef std::vector<nid_type> eid_list;$/;"	t	class:Graph
eid_set	Graph.hpp	/^	typedef std::set<eid_type> eid_set;$/;"	t	class:Graph
eid_type	Graph.hpp	/^	typedef int eid_type;$/;"	t	class:Graph
elapsed	CS207/Util.hpp	/^  duration elapsed() const {$/;"	f	class:CS207::Clock
elem	Point.hpp	/^    double elem[3];$/;"	m	union:Point::__anon1
element	Field.hpp	/^	typedef FieldElement element;$/;"	t	class:FiniteField
element	fields.cpp	/^typedef int_field::element element;$/;"	t	file:
element_list	Field.hpp	/^	typedef typename std::vector<value_type> element_list;$/;"	t	class:FiniteField
elements_	Field.hpp	/^	element_list elements_;$/;"	m	class:FiniteField
empty	Point.hpp	/^  static constexpr bool         empty() { return false; }$/;"	f	struct:Point
empty_node_map	CS207/SDLViewer.hpp	/^  std::map<typename G::node_type, unsigned> empty_node_map(const G&) const {$/;"	f	class:CS207::SDLViewer
end	ExpressionTree.hpp	/^	term_list::iterator end() {$/;"	f	class:ExpressionTree
end	Point.hpp	/^  const_iterator    end() const { return elem+3; }$/;"	f	struct:Point
end	Point.hpp	/^  iterator          end()       { return elem+3; }$/;"	f	struct:Point
equality_comparable	CS207/Util.hpp	/^struct equality_comparable {$/;"	s
error	error.hpp	/^void error(std::string s) {$/;"	f
event_loop	CS207/SDLViewer.hpp	/^  void event_loop() {$/;"	f	class:CS207::SDLViewer
event_loop_wrapper	CS207/SDLViewer.hpp	/^  static int event_loop_wrapper(void* _viewer_ptr) {$/;"	f	class:CS207::SDLViewer
event_thread_	CS207/SDLViewer.hpp	/^  SDL_Thread* event_thread_;$/;"	m	class:CS207::SDLViewer
exp_	ExpressionTree.hpp	/^	std::string exp_;$/;"	m	class:ExpressionTree
expression	ExpressionTree.hpp	/^	std::string expression() {$/;"	f	class:ExpressionTree
expression	polys.hpp	/^	std::string expression() {$/;"	f	class:Polynomial
eyeV	CS207/GLCamera.hpp	/^  Point eyeV;$/;"	m	class:CS207::GLCamera
f_	Field.hpp	/^		FiniteField* f_;$/;"	m	class:FiniteField::FieldElement
f_	Field.hpp	/^		FiniteField* f_;$/;"	m	class:FiniteField::Operator
f_composition	mass_spring.cpp	/^	typedef typename std::list<Rule*> f_composition;$/;"	t	struct:Constraint	file:
f_composition	mass_spring.cpp	/^	typedef typename std::list<Stimulus*> f_composition;$/;"	t	struct:Force	file:
fail_count	test_nodes.cpp	/^static unsigned fail_count = 0;$/;"	v	file:
find	Permutation.hpp	/^		char find( char b ) {$/;"	f	class:Cycle
for_i	Point.hpp	11;"	d
for_i	Point.hpp	239;"	d
forces_	mass_spring.cpp	/^	f_composition forces_;$/;"	m	struct:Force	file:
free_eids_	Graph.hpp	/^	std::stack<eid_type> free_eids_;$/;"	m	class:Graph
free_nids_	Graph.hpp	/^	std::stack<nid_type> free_nids_;$/;"	m	class:Graph
front	Point.hpp	/^  const_reference front() const { return elem[0]; }$/;"	f	struct:Point
front	Point.hpp	/^  reference       front()       { return elem[0]; }$/;"	f	struct:Point
g	CS207/Color.hpp	/^  value_type r, g, b;$/;"	m	struct:CS207::Color
g_	Graph.hpp	/^			const Graph* g_;$/;"	m	class:Graph::Edge
g_	Graph.hpp	/^			const Graph* g_;$/;"	m	class:Graph::Node
g_	Graph.hpp	/^			const Graph* g_;$/;"	m	class:Graph::TransformIter
gcd	primes.cpp	/^int gcd(int a, int b) {$/;"	f
get_operator	Field.hpp	/^	Operator get_operator(char c) {$/;"	f	class:FiniteField
getline_parsed	CS207/Util.hpp	/^std::istream& getline_parsed(std::istream& s, T& value)$/;"	f	namespace:CS207
gltype	CS207/SDLViewer.hpp	/^template <typename T> struct gltype {};$/;"	s	namespace:CS207
gltype	CS207/SDLViewer.hpp	/^template<> struct gltype<double>         : public gltype_v<GL_DOUBLE> {};$/;"	s	namespace:CS207
gltype	CS207/SDLViewer.hpp	/^template<> struct gltype<float>          : public gltype_v<GL_FLOAT> {};$/;"	s	namespace:CS207
gltype	CS207/SDLViewer.hpp	/^template<> struct gltype<int>            : public gltype_v<GL_INT> {};$/;"	s	namespace:CS207
gltype	CS207/SDLViewer.hpp	/^template<> struct gltype<short>          : public gltype_v<GL_SHORT> {};$/;"	s	namespace:CS207
gltype	CS207/SDLViewer.hpp	/^template<> struct gltype<unsigned char>  : public gltype_v<GL_UNSIGNED_BYTE> {};$/;"	s	namespace:CS207
gltype	CS207/SDLViewer.hpp	/^template<> struct gltype<unsigned int>   : public gltype_v<GL_UNSIGNED_INT> {};$/;"	s	namespace:CS207
gltype	CS207/SDLViewer.hpp	/^template<> struct gltype<unsigned short> : public gltype_v<GL_UNSIGNED_SHORT> {};$/;"	s	namespace:CS207
gltype_v	CS207/SDLViewer.hpp	/^template <GLenum V> struct gltype_v {$/;"	s	namespace:CS207
grav	mass_spring.cpp	/^static constexpr double grav = 9.81;$/;"	v	file:
handle_event	CS207/SDLViewer.hpp	/^  void handle_event(SDL_Event event) {$/;"	f	class:CS207::SDLViewer
has_edge	Graph.hpp	/^	eid_type has_edge(const node_type& n1, const node_type& n2) {$/;"	f	class:Graph
has_edge_	Graph.hpp	/^	eid_type has_edge_(const nid_type nid1, const nid_type nid2) {$/;"	f	class:Graph
head_term_	ExpressionTree.hpp	/^	term head_term_;$/;"	m	class:ExpressionTree
idx	Graph.hpp	/^		idx_type idx;$/;"	m	struct:Graph::EdgeInfo
idx	Graph.hpp	/^		idx_type idx;$/;"	m	struct:Graph::NodeInfo
idx2eid_	Graph.hpp	/^	std::vector<eid_type> idx2eid_;$/;"	m	class:Graph
idx2nid_	Graph.hpp	/^	std::vector<nid_type> idx2nid_;$/;"	m	class:Graph
idx_type	Graph.hpp	/^	typedef int idx_type;$/;"	t	class:Graph
implement_operator	ExpressionTree.hpp	/^	void implement_operator(char c, OPERATOR op) {$/;"	f	class:ExpressionTree
in_range	Field.hpp	/^	bool in_range(IT first, IT last, S e) {$/;"	f	class:FiniteField
incident_iterator	Graph.hpp	/^	typedef TransformIter<eid_set::iterator, edge_type> incident_iterator;$/;"	t	class:Graph
incoming_edge_begin	Graph.hpp	/^			incident_iterator incoming_edge_begin() {$/;"	f	class:Graph::Node
incoming_edge_end	Graph.hpp	/^			incident_iterator incoming_edge_end() {$/;"	f	class:Graph::Node
incoming_edges	Graph.hpp	/^		std::set<eid_type> incoming_edges;$/;"	m	struct:Graph::NodeInfo
index	Graph.hpp	/^			idx_type index() {$/;"	f	class:Graph::Edge
index	Graph.hpp	/^			idx_type index() {$/;"	f	class:Graph::Node
init	CS207/SDLViewer.hpp	/^  void init() {$/;"	f	class:CS207::SDLViewer
inner_prod	Point.hpp	/^double inner_prod(const Point& a, const Point& b) {$/;"	f
int_field	fields.cpp	/^typedef FiniteField<int,add_modN,mult_modN> int_field;$/;"	t	file:
invert	Permutation.hpp	/^		void invert() {$/;"	f	class:Cycle
invert	Permutation.hpp	/^		void invert() {$/;"	f	class:Permutation
inverted_	Permutation.hpp	/^		bool inverted_;$/;"	m	class:Cycle
inverted_map_	Permutation.hpp	/^		MAP inverted_map_;$/;"	m	class:Cycle
is_leaf	ExpressionTree.hpp	/^	bool is_leaf(term t) {$/;"	f	class:ExpressionTree
is_simplified	ExpressionTree.hpp	/^	bool is_simplified() {$/;"	f	class:ExpressionTree
is_valid_symbol	evaluate.cpp	/^bool is_valid_symbol(char c) {$/;"	f
isspace	ExpressionTree.hpp	/^	struct isspace {$/;"	s	class:ExpressionTree
it_	Graph.hpp	/^			IT it_;$/;"	m	class:Graph::TransformIter
iterator	Field.hpp	/^	typedef typename element_list::iterator iterator;$/;"	t	class:FiniteField
iterator	Point.hpp	/^  typedef double*         iterator;$/;"	t	struct:Point
iterator_category	Graph.hpp	/^			typedef std::input_iterator_tag iterator_category;$/;"	t	class:Graph::TransformIter
label_	CS207/SDLViewer.hpp	/^  std::string label_;$/;"	m	class:CS207::SDLViewer
launch	CS207/SDLViewer.hpp	/^  void launch() {$/;"	f	class:CS207::SDLViewer
leaves	ExpressionTree.hpp	/^		term_list leaves;$/;"	m	struct:ExpressionTree::term
less_than_comparable	CS207/Util.hpp	/^struct less_than_comparable {$/;"	s
lock_	CS207/SDLViewer.hpp	/^  SDL_mutex* lock_;$/;"	m	class:CS207::SDLViewer
lonely_branch	ExpressionTree.hpp	/^	bool lonely_branch(term t) {$/;"	f	class:ExpressionTree
lp_	shortest_path.cpp	/^	double lp_;$/;"	m	struct:MyColorFunc	file:
main	d3mult.cpp	/^int main(int argc, char** argv) {$/;"	f
main	evaluate.cpp	/^int main(int argc, char** argv) {$/;"	f
main	fields.cpp	/^int main() {$/;"	f
main	mass_spring.cpp	/^int main(int argc, char** argv) {$/;"	f
main	parse.cpp	/^int main(int argc, char** argv) {$/;"	f
main	pmul.cpp	/^int main (int argc, char* argv[]) {$/;"	f
main	polys.cpp	/^int main(int argc, char** argv) {$/;"	f
main	primes.cpp	/^int main(int argc, char** argv) {$/;"	f
main	shortest_path.cpp	/^int main(int argc, char** argv)$/;"	f
main	test_nodes.cpp	/^int main()$/;"	f
main	viewer.cpp	/^int main(int argc, char** argv)$/;"	f
make_heat	CS207/Color.hpp	/^  static Color make_heat(float v) {$/;"	f	struct:CS207::Color
make_hsv	CS207/Color.hpp	/^  static Color make_hsv(float h, float s, float v) {$/;"	f	struct:CS207::Color
make_rgb	CS207/Color.hpp	/^  static Color make_rgb(float r, float g, float b) {$/;"	f	struct:CS207::Color
make_set	pmul.cpp	/^void make_set( SET& e, string a , string b ) {$/;"	f
map	Field.hpp	/^	typedef std::unordered_map< T, T > map;$/;"	t	class:FiniteField
map_	Permutation.hpp	/^		MAP map_;$/;"	m	class:Cycle
mass	mass_spring.cpp	/^  double mass;     \/\/< Node mass$/;"	m	struct:node_data	file:
max_size	Point.hpp	/^  static constexpr size_type max_size() { return 3; }$/;"	f	struct:Point
mod	evaluate.cpp	/^	int mod;$/;"	m	struct:coeff_modulo	file:
mod_adder	evaluate.cpp	/^	mod_adder(int N) : N(N) {}$/;"	f	struct:mod_adder
mod_adder	evaluate.cpp	/^typedef struct mod_adder {$/;"	s	file:
mod_adder	evaluate.cpp	/^} mod_adder;$/;"	t	typeref:struct:mod_adder	file:
mod_multiplier	evaluate.cpp	/^	mod_multiplier(int N) : N(N) {}$/;"	f	struct:mod_multiplier
mod_multiplier	evaluate.cpp	/^typedef struct mod_multiplier {$/;"	s	file:
mod_multiplier	evaluate.cpp	/^} mod_multiplier;$/;"	t	typeref:struct:mod_multiplier	file:
mult_	Field.hpp	/^	multiplier mult_;$/;"	m	class:FiniteField
mult_modN	fields.cpp	/^	mult_modN(int N) : N(N) {}$/;"	f	struct:mult_modN
mult_modN	fields.cpp	/^struct mult_modN {$/;"	s	file:
multinv_map_	Field.hpp	/^	map multinv_map_;$/;"	m	class:FiniteField
multiplication_table_	Field.hpp	/^	table multiplication_table_;$/;"	m	class:FiniteField
multiplier	Field.hpp	/^	typedef MULT multiplier;$/;"	t	class:FiniteField
next_operation	ExpressionTree.hpp	/^	int next_operation(IT begin, IT end) {$/;"	f	class:ExpressionTree
nid1	Graph.hpp	/^		nid_type nid1;$/;"	m	struct:Graph::EdgeInfo
nid2	Graph.hpp	/^		nid_type nid2;$/;"	m	struct:Graph::EdgeInfo
nid_	Graph.hpp	/^			int nid_;$/;"	m	class:Graph::Node
nid_list	Graph.hpp	/^	typedef std::vector<nid_type> nid_list;$/;"	t	class:Graph
nid_type	Graph.hpp	/^	typedef int nid_type;$/;"	t	class:Graph
node	Graph.hpp	/^	node_type node(idx_type idx) {$/;"	f	class:Graph
node1	Graph.hpp	/^			node_type node1() {$/;"	f	class:Graph::Edge
node2	Graph.hpp	/^			node_type node2() {$/;"	f	class:Graph::Edge
node_begin	Graph.hpp	/^	node_iterator node_begin() {$/;"	f	class:Graph
node_data	mass_spring.cpp	/^struct node_data {$/;"	s	file:
node_end	Graph.hpp	/^	node_iterator node_end() {$/;"	f	class:Graph
node_iterator	Graph.hpp	/^	typedef TransformIter<nid_list::iterator, node_type> node_iterator;$/;"	t	class:Graph
node_type	Graph.hpp	/^	typedef Node node_type;$/;"	t	class:Graph
node_value_type	Graph.hpp	/^	typedef NodeData node_value_type;$/;"	t	class:Graph
nodes_	Graph.hpp	/^	std::vector<NodeInfo> nodes_;$/;"	m	class:Graph
norm	Point.hpp	/^double norm(const Point& a) {$/;"	f
normSq	Point.hpp	/^double normSq(const Point& a) {$/;"	f
norm_1	Point.hpp	/^double norm_1(const Point& a) {$/;"	f
norm_2	Point.hpp	/^double norm_2(const Point& a) {$/;"	f
norm_inf	Point.hpp	/^double norm_inf(const Point& a) {$/;"	f
num_edges	Graph.hpp	/^	size_t num_edges() {$/;"	f	class:Graph
num_nodes	Graph.hpp	/^	size_t num_nodes() {$/;"	f	class:Graph
ok_	CS207/SDLViewer.hpp	/^    bool ok_;$/;"	m	struct:CS207::SDLViewer::safe_lock
one_	Field.hpp	/^	value_type one_;$/;"	m	class:FiniteField
operator !=	CS207/Util.hpp	/^  friend bool operator!=(const T& a, const T& b) { return !(a == b); }$/;"	f	struct:equality_comparable
operator !=	Field.hpp	/^		bool operator!=(element b) {$/;"	f	class:FiniteField::FieldElement
operator !=	Point.hpp	/^  bool operator!=(const Point& b) const {$/;"	f	struct:Point
operator ()	CS207/SDLViewer.hpp	/^	Color operator()(const NODE& n) {$/;"	f	struct:CS207::PoissonColor
operator ()	CS207/SDLViewer.hpp	/^  Color operator()(const NODE&) {$/;"	f	struct:CS207::DefaultColor
operator ()	CS207/SDLViewer.hpp	/^  Point operator()(const NODE& n) {$/;"	f	struct:CS207::PoissonPosition
operator ()	CS207/SDLViewer.hpp	/^  Point operator()(const NODE& node) {$/;"	f	struct:CS207::DefaultPosition
operator ()	ExpressionTree.hpp	/^		bool operator()(char c) {$/;"	f	struct:ExpressionTree::isspace
operator ()	ExpressionTree.hpp	/^		bool operator()(std::string s) {$/;"	f	struct:ExpressionTree::isspace
operator ()	Field.hpp	/^		value_type operator()(value_type a, value_type b) {$/;"	f	class:FiniteField::Operator
operator ()	Permutation.hpp	/^		char operator()( char b ) {$/;"	f	class:Cycle
operator ()	Permutation.hpp	/^		char operator()( char b ) {$/;"	f	class:Permutation
operator ()	evaluate.cpp	/^	coeff_array operator()(coeff_array c) {$/;"	f	struct:coeff_modulo
operator ()	evaluate.cpp	/^	coeff_array operator()(coeff_array c) {$/;"	f	struct:coeff_power_swap
operator ()	evaluate.cpp	/^	int operator()(int a, int b) {$/;"	f	struct:mod_adder
operator ()	evaluate.cpp	/^	int operator()(int a, int b) {$/;"	f	struct:mod_multiplier
operator ()	evaluate.cpp	/^	string operator()(string s1, string s2) {$/;"	f	struct:mod_adder
operator ()	evaluate.cpp	/^	string operator()(string s1, string s2) {$/;"	f	struct:mod_multiplier
operator ()	evaluate.cpp	/^	string operator()(string s1, string s2) {$/;"	f	struct:poly_adder
operator ()	evaluate.cpp	/^	string operator()(string s1, string s2) {$/;"	f	struct:poly_multiplier
operator ()	fields.cpp	/^	int operator()(int a, int b) {$/;"	f	struct:add_modN
operator ()	fields.cpp	/^	int operator()(int a, int b) {$/;"	f	struct:mult_modN
operator ()	mass_spring.cpp	/^	Point operator()(Node n, double t) const {$/;"	f	struct:Force
operator ()	mass_spring.cpp	/^	void operator()(GraphType& g, double t) const {$/;"	f	struct:Constraint
operator ()	shortest_path.cpp	/^	CS207::Color operator()(const NODE& node) {$/;"	f	struct:MyColorFunc
operator ()	shortest_path.cpp	/^   bool operator()(const NODE& node1, const NODE& node2) const {$/;"	f	struct:MyComparator
operator *	Field.hpp	/^		element operator*(element b) {$/;"	f	class:FiniteField::FieldElement
operator *	Graph.hpp	/^			value_type operator*() {$/;"	f	class:Graph::TransformIter
operator *	Permutation.hpp	/^		Permutation& operator* (const Permutation& other) {$/;"	f	class:Permutation
operator *	Point.hpp	/^Point operator*(Point a, const Point& b) {$/;"	f
operator *	Point.hpp	/^Point operator*(Point a, double b) {$/;"	f
operator *	Point.hpp	/^Point operator*(double b, Point a) {$/;"	f
operator *	polys.hpp	/^	Polynomial operator*(Polynomial b) {$/;"	f	class:Polynomial
operator *=	Point.hpp	/^  Point& operator*=(const Point& b) {$/;"	f	struct:Point
operator *=	Point.hpp	/^  Point& operator*=(value_type b) {$/;"	f	struct:Point
operator +	Field.hpp	/^		element operator+(element b) {$/;"	f	class:FiniteField::FieldElement
operator +	Point.hpp	/^Point operator+(Point a, const Point& b) {$/;"	f
operator +	Point.hpp	/^Point operator+(Point a, double b) {$/;"	f
operator +	Point.hpp	/^Point operator+(const Point& a) {$/;"	f
operator +	Point.hpp	/^Point operator+(double b, Point a) {$/;"	f
operator +	mass_spring.cpp	/^	Constraint operator+(Constraint f) const {$/;"	f	struct:Constraint
operator +	mass_spring.cpp	/^	Force operator+(Force f) const {$/;"	f	struct:Force
operator +	polys.hpp	/^	Polynomial operator+(Polynomial b) {$/;"	f	class:Polynomial
operator ++	Graph.hpp	/^			TransformIter& operator++() {$/;"	f	class:Graph::TransformIter
operator +=	Point.hpp	/^  Point& operator+=(const Point& b) {$/;"	f	struct:Point
operator +=	Point.hpp	/^  Point& operator+=(value_type b) {$/;"	f	struct:Point
operator -	Field.hpp	/^		element operator-(element b) {$/;"	f	class:FiniteField::FieldElement
operator -	Point.hpp	/^Point operator-(Point a, const Point& b) {$/;"	f
operator -	Point.hpp	/^Point operator-(Point a, double b) {$/;"	f
operator -	Point.hpp	/^Point operator-(const Point& a) {$/;"	f
operator -	Point.hpp	/^Point operator-(double b, const Point& a) {$/;"	f
operator -=	Point.hpp	/^  Point& operator-=(const Point& b) {$/;"	f	struct:Point
operator -=	Point.hpp	/^  Point& operator-=(value_type b) {$/;"	f	struct:Point
operator /	Field.hpp	/^		element operator\/(element b) {$/;"	f	class:FiniteField::FieldElement
operator /	Point.hpp	/^Point operator\/(Point a, const Point& b) {$/;"	f
operator /	Point.hpp	/^Point operator\/(Point a, double b) {$/;"	f
operator /=	Point.hpp	/^  Point& operator\/=(const Point& b) {$/;"	f	struct:Point
operator /=	Point.hpp	/^  Point& operator\/=(value_type b) {$/;"	f	struct:Point
operator <	Graph.hpp	/^			bool operator<(const Edge& other) const {$/;"	f	class:Graph::Edge
operator <	Graph.hpp	/^			bool operator<(const Node& other) const {$/;"	f	class:Graph::Node
operator <<	Point.hpp	/^std::ostream& operator<<(std::ostream& s, const Point& a) {$/;"	f
operator <=	CS207/Util.hpp	/^  friend bool operator<=(const T& a, const T& b) { return !(b < a); }$/;"	f	struct:less_than_comparable
operator ==	Field.hpp	/^		bool operator==(element b) {$/;"	f	class:FiniteField::FieldElement
operator ==	Graph.hpp	/^			bool operator==(const Edge& other) const {$/;"	f	class:Graph::Edge
operator ==	Graph.hpp	/^			bool operator==(const Node& other) const {$/;"	f	class:Graph::Node
operator ==	Graph.hpp	/^			bool operator==(const TransformIter& other) const {$/;"	f	class:Graph::TransformIter
operator ==	Point.hpp	/^  bool operator==(const Point& b) const {$/;"	f	struct:Point
operator >	CS207/Util.hpp	/^  friend bool operator> (const T& a, const T& b) { return   b < a;  }$/;"	f	struct:less_than_comparable
operator >=	CS207/Util.hpp	/^  friend bool operator>=(const T& a, const T& b) { return !(a < b); }$/;"	f	struct:less_than_comparable
operator >>	CS207/Util.hpp	/^std::istream& operator>>(std::istream& s, std::array<T,N>& v) {$/;"	f	namespace:CS207
operator >>	Point.hpp	/^std::istream& operator>>(std::istream& s, Point& a) {$/;"	f
operator []	Point.hpp	/^  const_reference operator[](size_type i) const { return elem[i]; }$/;"	f	struct:Point
operator []	Point.hpp	/^  reference       operator[](size_type i)       { return elem[i]; }$/;"	f	struct:Point
operator ^	Permutation.hpp	/^		Permutation& operator^ (int pow) {$/;"	f	class:Permutation
outgoing_edge_begin	Graph.hpp	/^			incident_iterator outgoing_edge_begin() {$/;"	f	class:Graph::Node
outgoing_edge_end	Graph.hpp	/^			incident_iterator outgoing_edge_end() {$/;"	f	class:Graph::Node
outgoing_edges	Graph.hpp	/^		std::set<eid_type> outgoing_edges;$/;"	m	struct:Graph::NodeInfo
p_	shortest_path.cpp	/^   Point p_;$/;"	m	struct:MyComparator	file:
pan	CS207/GLCamera.hpp	/^  inline void pan(float x, float y, float z) {$/;"	f	class:CS207::GLCamera
perm	shortest_path.cpp	/^	bool perm;$/;"	m	struct:MyNodeData	file:
point	CS207/GLCamera.hpp	/^  Point point;$/;"	m	class:CS207::GLCamera
pointer	Graph.hpp	/^			typedef T* pointer;$/;"	t	class:Graph::TransformIter
poly_adder	evaluate.cpp	/^	poly_adder(coeff_modulo c) : simplifier(c) {}$/;"	f	struct:poly_adder
poly_adder	evaluate.cpp	/^	poly_adder(int max_coeff) {$/;"	f	struct:poly_adder
poly_adder	evaluate.cpp	/^typedef struct poly_adder {$/;"	s	file:
poly_adder	evaluate.cpp	/^} poly_adder;$/;"	t	typeref:struct:poly_adder	file:
poly_multiplier	evaluate.cpp	/^	poly_multiplier(coeff_modulo s, coeff_power_swap r) : $/;"	f	struct:poly_multiplier
poly_multiplier	evaluate.cpp	/^typedef struct poly_multiplier {$/;"	s	file:
poly_multiplier	evaluate.cpp	/^} poly_multiplier;$/;"	t	typeref:struct:poly_multiplier	file:
position	Graph.hpp	/^			Point& position() {$/;"	f	class:Graph::Node
position	Graph.hpp	/^			const Point& position() const {$/;"	f	class:Graph::Node
position	Graph.hpp	/^		mutable Point position;$/;"	m	struct:Graph::NodeInfo
pow	evaluate.cpp	/^	int pow; $/;"	m	struct:coeff_power_swap	file:
print	polys.hpp	/^	void print() {$/;"	f	class:Polynomial
print_terms_	ExpressionTree.hpp	/^	void print_terms_(term t) {$/;"	f	class:ExpressionTree
print_tree	ExpressionTree.hpp	/^	void print_tree() {$/;"	f	class:ExpressionTree
r	CS207/Color.hpp	/^  value_type r, g, b;$/;"	m	struct:CS207::Color
random	CS207/Util.hpp	/^double random() {$/;"	f	namespace:CS207
random	CS207/Util.hpp	/^double random(double a, double b) {$/;"	f	namespace:CS207
reducers	evaluate.cpp	/^	std::vector< coeff_power_swap > reducers;$/;"	m	struct:poly_multiplier	file:
reference	Graph.hpp	/^			typedef T& reference;$/;"	t	class:Graph::TransformIter
reference	Point.hpp	/^  typedef double&         reference;$/;"	t	struct:Point
remove_edge	Graph.hpp	/^	bool remove_edge(Edge e) {$/;"	f	class:Graph
remove_node	Graph.hpp	/^	void remove_node(Node n) {$/;"	f	class:Graph
render	CS207/SDLViewer.hpp	/^  void render() {$/;"	f	class:CS207::SDLViewer
render_label	CS207/SDLViewer.hpp	/^  void render_label() {$/;"	f	class:CS207::SDLViewer
render_lcd_segments	CS207/SDLViewer.hpp	/^  void render_lcd_segments(unsigned segments) {$/;"	f	class:CS207::SDLViewer
render_requested_	CS207/SDLViewer.hpp	/^  bool render_requested_;$/;"	m	class:CS207::SDLViewer
request_render	CS207/SDLViewer.hpp	/^  void request_render() {$/;"	f	class:CS207::SDLViewer
rest_length	mass_spring.cpp	/^	double rest_length;$/;"	m	struct:edge_data	file:
rightV	CS207/GLCamera.hpp	/^  Point rightV;$/;"	m	class:CS207::GLCamera
rotate_x	CS207/GLCamera.hpp	/^  inline void rotate_x(float angle) {$/;"	f	class:CS207::GLCamera
rotate_y	CS207/GLCamera.hpp	/^  inline void rotate_y(float angle) {$/;"	f	class:CS207::GLCamera
safe_lock	CS207/SDLViewer.hpp	/^    safe_lock(SDLViewer* v)$/;"	f	struct:CS207::SDLViewer::safe_lock
safe_lock	CS207/SDLViewer.hpp	/^  struct safe_lock {$/;"	s	class:CS207::SDLViewer
scalar	mass_spring.cpp	/^typedef Point::value_type scalar;$/;"	t	file:
seconds	CS207/Util.hpp	/^  double seconds() const {$/;"	f	class:CS207::Clock
set_label	CS207/SDLViewer.hpp	/^  void set_label(const std::string& str) {$/;"	f	class:CS207::SDLViewer
set_label	CS207/SDLViewer.hpp	/^  void set_label(double d) {$/;"	f	class:CS207::SDLViewer
set_ortho	CS207/GLCamera.hpp	/^  void set_ortho(double left, double right, double bottom, double top,$/;"	f	class:CS207::GLCamera
set_perspective	CS207/GLCamera.hpp	/^  void set_perspective(double fovy, double aspect,$/;"	f	class:CS207::GLCamera
set_view	CS207/GLCamera.hpp	/^  inline void set_view() const {$/;"	f	class:CS207::GLCamera
sf_print	test_nodes.cpp	/^void sf_print(T a, string msg = "") {$/;"	f
sf_print	test_nodes.cpp	/^void sf_print(bool sf, string msg = "") {$/;"	f
shortest_path_lengths	shortest_path.cpp	/^double shortest_path_lengths(GraphType& g, const Point& point) {$/;"	f
simplifier	evaluate.cpp	/^	coeff_modulo simplifier;$/;"	m	struct:poly_adder	file:
simplifier	evaluate.cpp	/^	coeff_modulo simplifier;$/;"	m	struct:poly_multiplier	file:
simplify	polys.hpp	/^	void simplify(FUNCT f) {$/;"	f	class:Polynomial
simplify_	ExpressionTree.hpp	/^	term simplify_(term t, OPERATION op, int op_code) {$/;"	f	class:ExpressionTree
size	Graph.hpp	/^	size_t size() {$/;"	f	class:Graph
size	Point.hpp	/^  static constexpr size_type     size() { return 3; }$/;"	f	struct:Point
size_type	Permutation.hpp	/^typedef unsigned size_type;$/;"	t
size_type	Point.hpp	/^  typedef std::size_t     size_type;$/;"	t	struct:Point
sleep	CS207/Util.hpp	/^int sleep(double t) {$/;"	f	namespace:CS207
start	CS207/Util.hpp	/^  void start() {$/;"	f	class:CS207::Clock
starttime_	CS207/Util.hpp	/^  time_point starttime_;$/;"	m	class:CS207::Clock
str_len	ExpressionTree.hpp	/^	int str_len(const char* s) {$/;"	f	class:ExpressionTree
string	evaluate.cpp	/^typedef std::string string;$/;"	t	file:
sub	evaluate.cpp	/^	coeff_array sub;$/;"	m	struct:coeff_power_swap	file:
surface_	CS207/SDLViewer.hpp	/^  SDL_Surface* surface_;$/;"	m	class:CS207::SDLViewer
symp_euler_step	mass_spring.cpp	/^double symp_euler_step(G& g, double t, double dt, F force) {$/;"	f
table	Field.hpp	/^	typedef std::unordered_map< T, std::unordered_map<T, T> > table;$/;"	t	class:FiniteField
tag	ExpressionTree.hpp	/^		int tag;$/;"	m	struct:ExpressionTree::term
temp	shortest_path.cpp	/^	bool temp;$/;"	m	struct:MyNodeData	file:
term	ExpressionTree.hpp	/^		term() : tag(-1), value(value_type()) {$/;"	f	struct:ExpressionTree::term
term	ExpressionTree.hpp	/^	struct term {$/;"	s	class:ExpressionTree
term	polys.hpp	/^typedef e_tree::term term;$/;"	t
term_list	ExpressionTree.hpp	/^	typedef std::vector<term> term_list;$/;"	t	class:ExpressionTree
tick_type	CS207/Util.hpp	/^  typedef typename duration::rep             tick_type;$/;"	t	class:CS207::Clock
time_point	CS207/Util.hpp	/^  typedef typename clock::time_point         time_point;$/;"	t	class:CS207::Clock
totally_ordered	CS207/Util.hpp	/^struct totally_ordered$/;"	s
trim	ExpressionTree.hpp	/^	std::string trim(std::string s) {$/;"	f	class:ExpressionTree
type	Field.hpp	/^		char type;$/;"	m	class:FiniteField::Operator
unlock	CS207/SDLViewer.hpp	/^    void unlock() {$/;"	f	struct:CS207::SDLViewer::safe_lock
upV	CS207/GLCamera.hpp	/^  Point upV;$/;"	m	class:CS207::GLCamera
v_	CS207/SDLViewer.hpp	/^    SDLViewer* v_;$/;"	m	struct:CS207::SDLViewer::safe_lock
val	Field.hpp	/^		value_type val;$/;"	m	class:FiniteField::FieldElement
value	CS207/SDLViewer.hpp	/^  static constexpr GLenum value = V;$/;"	m	struct:CS207::gltype_v
value	ExpressionTree.hpp	/^		value_type value;$/;"	m	struct:ExpressionTree::term
value	Graph.hpp	/^			const edge_value_type& value() const {$/;"	f	class:Graph::Edge
value	Graph.hpp	/^			const node_value_type& value() const {$/;"	f	class:Graph::Node
value	Graph.hpp	/^			edge_value_type& value() {$/;"	f	class:Graph::Edge
value	Graph.hpp	/^			node_value_type& value() {$/;"	f	class:Graph::Node
value_type	CS207/Color.hpp	/^  typedef float value_type;$/;"	t	struct:CS207::Color
value_type	ExpressionTree.hpp	/^	typedef std::string value_type;$/;"	t	class:ExpressionTree
value_type	Field.hpp	/^	typedef T value_type;$/;"	t	class:FiniteField
value_type	Graph.hpp	/^			typedef T value_type;$/;"	t	class:Graph::TransformIter
value_type	Point.hpp	/^  typedef double          value_type;$/;"	t	struct:Point
velocity	mass_spring.cpp	/^  Point velocity;  \/\/< Node velocity$/;"	m	struct:node_data	file:
view_point	CS207/GLCamera.hpp	/^  inline void view_point(const Point& p) {$/;"	f	class:CS207::GLCamera
view_point	CS207/GLCamera.hpp	/^  inline void view_point(float x, float y, float z) {$/;"	f	class:CS207::GLCamera
window_height	CS207/SDLViewer.hpp	/^  int window_height() const {$/;"	f	class:CS207::SDLViewer
window_height_	CS207/SDLViewer.hpp	/^  int window_height_;$/;"	m	class:CS207::SDLViewer
window_width	CS207/SDLViewer.hpp	/^  int window_width() const {$/;"	f	class:CS207::SDLViewer
window_width_	CS207/SDLViewer.hpp	/^  int window_width_;$/;"	m	class:CS207::SDLViewer
x	Point.hpp	/^      double x;$/;"	m	struct:Point::__anon1::__anon2
y	Point.hpp	/^      double y;$/;"	m	struct:Point::__anon1::__anon2
z	Point.hpp	/^      double z;$/;"	m	struct:Point::__anon1::__anon2
zero_	Field.hpp	/^	value_type zero_;$/;"	m	class:FiniteField
zoom	CS207/GLCamera.hpp	/^  inline void zoom(float d) {$/;"	f	class:CS207::GLCamera
zoom_mag	CS207/GLCamera.hpp	/^  inline void zoom_mag(float d) {$/;"	f	class:CS207::GLCamera
~ExpressionTree	ExpressionTree.hpp	/^	~ExpressionTree() {$/;"	f	class:ExpressionTree
~SDLViewer	CS207/SDLViewer.hpp	/^  ~SDLViewer() {$/;"	f	class:CS207::SDLViewer
~safe_lock	CS207/SDLViewer.hpp	/^    ~safe_lock() {$/;"	f	struct:CS207::SDLViewer::safe_lock
